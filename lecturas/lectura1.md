# Collaborative Filtering Recommender Systems

Hoy en día, los sistemas recomendadores son cada vez más familiares para un usuario promedio, ya que se encuentran en muchas de las aplicaciones que son de uso diario, como lo es Youtube, Spotify, Netflix, Amazon Prime, MercaLibre, entre otros. El objetivo de un sistema recomendador es acercar al usuario y ayudarlo a seleccionar un *item* en particular entre la gran cantidad de alternativas que este tiene a su alcance.

En este *paper* se profundiza y explica acerca de un sistema recomendador en particular, *Collaborative Filtering Systems*, que es el proceso de evaluar *items* de acuerdo a las opiniones de los otros usuarios. De esta manera, con este tipo de sistemas se puede lograr predecir la clasificación (*rating*) que un usuario le entregaría a un *item* en particular y/o recomendarle algún *item*. 

La gran ventaja que posee este sistema recomendador es que los *ratings* entregados a los *items* provienen directamente de algún usuario, lo que se conoce como *ratings* explícitos o de una inferencia a partir de estos lo que se conoce como *ratings* implícitos. 

El algoritmo que mayormente describen en el *paper* es el de *User-Based Nearest Neighbor* que principalmente consiste en utilizar los *ratings* de los usuarios "más parecidos" en cuanto a gustos con el usuario activo para predecir el *rating* que este usuario le entregaría a un *item* que no ha seleccionado. Hago énfasis en "más parecidos" porque en el *paper* se menciona que utilizan la correlación de *Pearson* para determinar la similitud entre los usuarios, sin embargo, no mencionan por qué no probaron otros tipos de correlación, dejando abierta así esta posibilidad. También es importante mencionar que una vez que se calculan la similitud de los vecinos, se debe utilizar una cantidad `n` de vecinos, lo que se conoce como *KNN*, y dado que hoy en día la cantidad de información con la que pueden llegar a contar grandes empresas es de millones, es que podrían haber propuesto algún número mínimo, rango o máximo de vecinos a comparar, ya que ellos mismos mencionan que computacionalmente en cuanto a memoria y tiempo no es posible de realizar con todos los vecinos, pero acotar matemáticamente este número hubiera sido muy práctico.

La clasificación que realizan de los algoritmos es de aquellos que son probabilísticos y aquellos que no como el anteriormente mencionado. La gran ventaja de los algoritmos probabilísticos es que entregan la verosimilitud de la predicción así como también la confianza con la que realizan la predicción, información que es valiosa para el usuario ya que le entrega una explicación de dicha recomendación, y así el usuario mismo determinar si dicha recomendación es útil o no de acuerdo a la información que entrega. Un ejemplo de esto corresponde a la plataforma de Netflix. Recuerdo que hace algunos años, el sistema de *ratings* correspondía a estrellas y permitía comentar en palabras la opinión acerca de un *item* lo que personalmente lo encontraba valioso (siempre que no hubiera *spoilers*, xD), pero hoy en día, el sistema consiste en indicar si dicho *item* te gusta (*I like This*) o que no es para ti (*Not for me*) sin una opinión escrita, además de entregar un porcentaje de *match* para el *item*. Esto es un claro cambio de paradigma de un sistema recomendador, en el que para el algoritmo no es importante cuánto te gusta o no dicho *item* ni tampoco cuánto le ha gustado a la gente, si no más bien si está dentro o no de tus gustos y con cuánta confianza te puedo recomendar este otro *item*. De esta manera, la platorma no está tan interesada en predecir el *rating* que le darías (darías porque en la práctica la plataforma no te permite dar un *rating* numérico) si no que en recomendarte un *item* que vayas a ver.

En cuanto a las desventajas de *CF* se tiene el *cold start* que es cuando hay pocos *ratings* y/o pocos usuarios, nuevos usuarios o nuevos *items*, lo que hace que el algoritmo realice malas recomendaciones, así como también la cantidad de memoria y tiempo que requiere debido a la cantidad de *items* y usuarios, o también el hecho de que recomienda *items* similares y no algo totalmente nuevo (*novelty*), sin embargo, en la práctica se utilizan técnicas que se mencionan en el *paper* que palean estas complicaciones, como lo es generar distribuciones de *ratings* para un nuevo *item*, solicitarle al usuario sus gustos principales, utilizar un rango acotado de usuarios, etc. 

En resumen, *CF* es un buen sistema recomendador siempre y cuando esté acompañado de otras técnicas para ayudar a palear sus desventajas, y que las decisiones de implementación del algoritmo sean las más eficientes en cuanto a tiempo y consumo de memoria en la ejecución de este, en caso contrario la experiencia de usuario perjudicaría a la aplicación, y la que dejaría de ser recomendada sería esta misma.

